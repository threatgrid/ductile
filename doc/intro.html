<!DOCTYPE html PUBLIC ""
    "">
<html><head><meta charset="UTF-8" /><title>Ductile</title><link rel="stylesheet" type="text/css" href="css/default.css" /><link rel="stylesheet" type="text/css" href="css/highlight.css" /><script type="text/javascript" src="js/highlight.min.js"></script><script type="text/javascript" src="js/jquery.min.js"></script><script type="text/javascript" src="js/page_effects.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div id="header"><h2>Generated by <a href="https://github.com/weavejester/codox">Codox</a></h2><h1><a href="index.html"><span class="project-title"><span class="project-name">Ductile</span> <span class="project-version">0.4.3-SNAPSHOT</span></span></a></h1></div><div class="sidebar primary"><h3 class="no-link"><span class="inner">Project</span></h3><ul class="index-link"><li class="depth-1 "><a href="index.html"><div class="inner">Index</div></a></li></ul><h3 class="no-link"><span class="inner">Topics</span></h3><ul><li class="depth-1  current"><a href="intro.html"><div class="inner"><span>Ductile</span></div></a></li></ul><h3 class="no-link"><span class="inner">Namespaces</span></h3><ul><li class="depth-1"><div class="no-link"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>ductile</span></div></div></li><li class="depth-2"><a href="ductile.auth.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>auth</span></div></a></li><li class="depth-3"><a href="ductile.auth.api-key.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>api-key</span></div></a></li><li class="depth-2 branch"><a href="ductile.conn.html"><div class="inner"><span class="tree" style="top: -52px;"><span class="top" style="height: 61px;"></span><span class="bottom"></span></span><span>conn</span></div></a></li><li class="depth-2 branch"><a href="ductile.document.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>document</span></div></a></li><li class="depth-2 branch"><a href="ductile.index.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>index</span></div></a></li><li class="depth-2 branch"><a href="ductile.pagination.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>pagination</span></div></a></li><li class="depth-2 branch"><a href="ductile.query.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>query</span></div></a></li><li class="depth-2"><a href="ductile.schemas.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>schemas</span></div></a></li></ul></div><div class="document" id="content"><div class="doc"><div class="markdown"><h1><a href="#ductile" name="ductile"></a>Ductile</h1>
<p>A minimalist clojure library for Elasticsearch REST API.</p>
<p>Itâ€™s currently compatible with Elasticsearch 7.x. Ductile proposes a limited support to prior Elasticsearch version (5 and 6) through a compatibility mode that is more intended to help migrating data.</p>
<h2><a href="#usage" name="usage"></a>Usage</h2>
<h3><a href="#create-a-connection-to-an-elasticsearch-instance" name="create-a-connection-to-an-elasticsearch-instance"></a>Create a connection to an elasticsearch instance</h3>
<pre><code class="clojure">(require '[ductile.conn :as es-conn])

(def c (es-conn/connect {:host "localhost"
                         :port 9200
                         :version 7
                         :protocol :http
                         :timeout 20000
                         :auth {:type :api-key
                                :params {:id "ngkvLnYB4ZehGW1qU-Xz"
                                         :api-key "6HMnACPRSVWSMvZCf9VcGg"}}}))
</code></pre>
<p>Only <code>host</code> and <code>port</code> are required. The default values for the optional fields are: - <code>version</code>: <code>7</code>. - <code>protocol</code>: <code>:http</code>. - <code>timeout</code>: <code>30000.</code> - <code>auth</code>: none.</p>
<h4><a href="#authentication" name="authentication"></a>Authentication</h4>
<p>Here is the schema of the <code>auth</code> values:</p>
<pre><code class="clojure">(s/defschema AuthParams
  {:type (s/enum :basic-auth :api-key :oauth-token :bearer :headers)
   :params {s/Keyword s/Str}})
</code></pre>
<p>The <code>type</code> field specifies the auth method and the <code>params</code> contains the authentication parameters. Here are some examples for each <code>type</code> value:</p>
<ul>
  <li>Authorization headers</li>
</ul>
<pre><code class="clojure">{:type :headers
 :params {:authorization "ApiKey bmdrdkxuWUI0WmVoR1cxcVUtWHo6NkhNbkFDUFJTVldTTXZaQ2Y5VmNHZw=="}}
</code></pre>
<ul>
  <li>API Key</li>
</ul>
<pre><code class="clojure">{:type :api-key
 :params {:id "ngkvLnYB4ZehGW1qU-Xz"
          :api-key "6HMnACPRSVWSMvZCf9VcGg"}}
</code></pre>
<ul>
  <li>Basic Auth</li>
</ul>
<pre><code class="clojure">{:type :basic-auth
:params {:user "the-login" :pwd "the-pwd"}}
</code></pre>
<ul>
  <li>OAuth token</li>
</ul>
<pre><code class="clojure">{:type :oauth-token
:params {:token "any-token"}}
</code></pre>
<ul>
  <li>Bearer OAuth token</li>
</ul>
<p>Like Oauth token but prefixes the token with <code>Bearer</code> if missing.</p>
<pre><code class="clojure  ">{:type :bearer
 :params {:token "any-token"}}

</code></pre>
<p>Only <code>host</code> and <code>port</code> are required, the default version value is 7, the default protocol value is <code>:http</code>, and the default timeout is 30000 ms. The <code>version</code> field accepts an integer value to specify the major Elasticsearch version, and is used for the compatibility mode with Elasticsearch 5.x and 6.x.</p>
<h3><a href="#index-operations" name="index-operations"></a>index operations</h3>
<pre><code class="clojure">(require '[ductile.index :as es-index])

(sut/index-exists? conn "new_index")
;;false

(def test-config {:settings {:number_of_shards 3
                             :number_of_replicas 1
                             :refresh_interval "1s"}
                  :mappings {:properties {:name {:type :text}
                                          :age {:type :long}
                                          :description {:type :text}}}
                  :aliases {:test-alias {}}})
;; for Elasticsearch 5.x compatibility, you must specify the document type(s) in the mappings.

(es-index/create! c "test-index" test-config)

;; you can then delete or close that index
(es-index/close! c "test-index")
(es-index/delete! c "test-index")


;; you can also manage templates
(es-index/create-template! c "test-index" test-config ["foo*" "bar*"])

;; when the index-patterns are not provided, one will be generated from the name with a wildcard suffix
;; for instance, the following template will have the index-patterns ["test-index*"]
(es-index/create-template! c "test-index" test-config)

(es-index/get-template c "test-index")
(es-index/delete-template! c "test-index")
</code></pre>
<h3><a href="#crud-operations" name="crud-operations"></a>crud operations</h3>
<ul>
  <li>
  <p>create a document, and use the id field as document id</p>
  <pre><code class="clojure">(require '[ductile.document :as es-doc]) 
(es-doc/create-doc c
               "test-index"
               {:id 1
               :name "John Doe"
               :description "an anonymous coward"}
               {:refresh "wait_for"})
</code></pre></li>
</ul>
<pre><code class="javascript">{:id 1, :name "John Doe", :description "an anonymous coward"}
</code></pre>
<p>if you try to create another document with the same id, it will throw an ExceptionInfo</p>
<pre><code class="clojure">(es-doc/create-doc c
                      "test-index"
                   {:id 1
                    :name "Jane Doe"
                    :description "another anonymous coward"}
                   {:refresh "wait_for"})
;; Execution error (ExceptionInfo) at ductile.conn/safe-es-read (conn.clj:54).
;; ES query failed
</code></pre>
<p>it will return the document creation result</p>
<pre><code class="javascript"> {:_index "test-index",
  :_type "_doc",
  :_id "1",
  :_version 1,
  :result "created",
  :_shards {:total 2, :successful 1, :failed 0},
  :_seq_no 0,
  :_primary_term 1}
</code></pre>
<p>if you do not provide the id field, elasticsearch will insert the document and generate an id</p>
<pre><code class="clojure">(es-doc/create-doc c
                   "test-index"
                   {:name "Jane Doe 2"
                    :description "yet another anonymous coward"}
                   {:refresh "wait_for"})
</code></pre>
<pre><code class="javascript"> {:_index "test-index",
  :_type "_doc",
  :_id "EBD9L3ABLWPPOW84CV6I",
  :_version 1,
  :result "created",
  :_shards {:total 2, :successful 1, :failed 0},
  :_seq_no 0,
  :_primary_term 1}
</code></pre>
<p>Using the field <code>id</code> as document id is the default behavior. However you can provide a mk-id function that takes the created document as parameter to override that behavior and build the id from the document. For instance you could simply provide another field name.</p>
<pre><code class="clojure">(es-doc/create-doc c
                   "test-index"
                   {:uri "http://cisco.com/sighting/1"
                    :name "Jane Doe 2"
                    :description "yet another anonymous coward"}
                   {:refresh "wait_for"
                   :mk-id :uri})
</code></pre>
<pre><code class="javascript"> {:_index "test-index",
  :_type "_doc",
  :_id "http://cisco.com/sighting/1",
  :_version 1,
  :result "created",
  :_shards {:total 2, :successful 1, :failed 0},
  :_seq_no 0,
  :_primary_term 1}
</code></pre>
<p>another example with a function that return the hash of the created document</p>
<pre><code class="clojure">(es-doc/create-doc c
                   "test-index"
                   {:name "Jane Doe 2"
                    :description "yet another anonymous coward"}
                   {:refresh "wait_for"
                   :mk-id hash})
</code></pre>
<pre><code class="javascript"> {:_index "test-index",
  :_type "_doc",
  :_id "1474268975",
  :_version 1,
  :result "created",
  :_shards {:total 2, :successful 1, :failed 0},
  :_seq_no 0,
  :_primary_term 1}
</code></pre>
<p>you can similarly create a document with index-doc, but if the document already exists it will erase it</p>
<pre><code class="clojure">(es-doc/index-doc c
                  "test-index"
                  {:id 2
                   :name "Jane Doe"
                   :description "another anonymous coward"}
                  {:refresh "wait_for"})

(es-doc/index-doc c
                  "test-index"
                  {:name "John Doe"
                   :description "not so anonymous coward"}
                  {:refresh "wait_for"})
</code></pre>
<p>the 4th parameter offers to set the <code>refresh</code> parameter and can take same string values as corresponding ES query parameter: <code>true</code>, â€˜falseâ€™, â€˜wait_forâ€™</p>
<ul>
  <li>patch a document</li>
</ul>
<pre><code class="clojure">(es-doc/update-doc c
                   "test-index"
                   1
                   {:age 36
                    :description "anonymous but known age"}
                   {:refresh "wait_for"})
</code></pre>
<p>it returns the patched document</p>
<pre><code class="javascript">{:id 1, :name "Jane Doe", :description "anonymous with know age", :age 36}
</code></pre>
<ul>
  <li>retrieve a document</li>
</ul>
<pre><code class="clojure">(es-doc/get-doc c
                "test-index"
                1
                {})
</code></pre>
<pre><code class="javascript">{:id 1, :name "Jane Doe", :description "anonymous with know age", :age 36}
</code></pre>
<ul>
  <li>delete a document</li>
</ul>
<pre><code class="clojure">(es-doc/delete-doc c
                  "test-index"
                  1
                  {:refresh "wait_for"})
 ;; true
 
 ;;you can also delete documents by query
 (es-doc/delete-by-query conn
                        ["test_index-1"]
                        {:query_string {:query "anonymous"}}
                        {:wait_for_completion true
                        :refresh "true"})))
 
</code></pre>
<ul>
  <li>Elasticsearch 5.x compatibility</li>
</ul>
<p>Any of the previous functions can be used on an Elasticsearch 5.x cluster by specifying the document type as a supplementary parameter after the index name. </p>
<pre><code class="clojure">(es-doc/get-doc c
                "test-index"
                "test-type"
                1
                {})
</code></pre>
<pre><code class="javascript">{:id 1, :name "Jane Doe", :description "anonymous with know age", :age 36}
</code></pre>
<h3><a href="#and-of-course-you-can-query-it-" name="and-of-course-you-can-query-it-"></a>and of course you can query it!</h3>
<p>you can either provide classical elasticsearch queries or use some helpers from <code>ductile.query</code> namespace</p>
<pre><code class="clojure">(require `[ductile.query :as es-query])
(es-doc/query c
              "test-index"
              (es-query/ids [1 2])
              {})
</code></pre>
<pre><code class="javascript">{:data
 ({:id 2, :name "Jane Doe", :description "another anonymous coward"}),
 :paging {:total-hits 1}}
</code></pre>
<p>if you need all metadata you can use the full-hits? option</p>
<pre><code class="clojure">(clojure.pprint/pprint
  (es-doc/query c
                "test-index"
                {:match_all {}}
                {:full-hits? true
                 :sort {"id" {:order :desc}}
                 :limit 2}))
</code></pre>
<p>it will return not only the matched documents but also meta data like <code>_index</code> and <code>_score</code></p>
<pre><code class="javascript">{:data
 [{:_index "test-index",
   :_type "_doc",
   :_id "2",
   :_score nil,
   :_source
   {:id 2, :name "Jane Doe", :description "another anonymous coward"},
   :sort [2]}
  {:_index "test-index",
   :_type "_doc",
   :_id "1",
   :_score nil,
   :_source
   {:id 1, :name "Jane Doe", :description "another anonymous coward"},
   :sort [1]}],
 :paging
 {:total-hits 3,
  :next {:limit 2, :offset 2, :search_after [1]},
  :sort [1]}}
</code></pre>
<p>Ductile also provides a search function with a simple interface that offers to use a Mongo like filters lucene query string to easily match documents</p>
<pre><code class="clojure">(es-doc/search-docs c
                    "test-index"
                    {:query_string {:query "anonymous"}}
                    {:age 36}
                    {:sort {:name {:order :desc}}})
</code></pre>
<h3><a href="#test-stubbing" name="test-stubbing"></a>Test stubbing</h3>
<p>To stub ES calls, provide a custom <code>:request-fn</code> to <code>es-conn/connect</code>. It should implement the same interface as the 1-argument version of <code>clj-http.client/request</code>.</p>
<pre><code class="clojure">(require '[ductile.conn :as es-conn]
         '[clj-http.client :as client])

(def c (es-conn/connect {:host "localhost"
                         :port 9200
                         :request-fn (fn [req]
                                       {:status 200
                                        :headers {:content-type "application/clojure"}})}))
</code></pre>
<p>See the middleware provided by <code>clj-http.client/wrap-*</code> for simulating more interesting cases. For example, this intercepts query-params and prints them:</p>
<pre><code class="clojure">(require '[ductile.conn :as es-conn]
         '[ring.util.codec :refer [form-decode]]
         '[clojure.walk :refer [keywordize-keys]]
         '[clj-http.client :as client])

(def c (es-conn/connect {:host "localhost"
                         :port 9200
                         :request-fn
                         (-&gt; (fn [req]
                               (prn {:query-params (keywordize-keys (form-decode (:query-string req)))})
                               {:status 200
                                :headers {:content-type "application/clojure"}})
                             client/wrap-query-params)}))
</code></pre>
<h2><a href="#license" name="license"></a>License</h2>
<p>Copyright Â© Cisco Systems</p>
<p>This program and the accompanying materials are made available under the terms of the Eclipse Public License 2.0 which is available at <a href="http://www.eclipse.org/legal/epl-2.0">http://www.eclipse.org/legal/epl-2.0</a>.</p></div></div></div></body></html>